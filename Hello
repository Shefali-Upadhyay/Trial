Hereâ€™s the combined test file with all your existing tests plus the suggested additions for:

Dispatching ageValidationAction

Dispatching lastAction.getField on focus

Testing input disabling with authenticateType as 'myinfo'

Verifying proper formatting (e.g., padding 07 for DD)


import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import Date from "./dates";
import validateService from "../../../services/validation-service";
import errorMsg from "../../../assets/_json/error.json";
import thunk from "redux-thunk";
import * as ageValidationActions from "../../../utils/store/age-validation-slice";
import { lastAction } from "../../../utils/store/last-accessed-slice";

jest.mock("../../../services/validation-service", () => ({
  isValidDate: jest.fn(),
  calculateAge: jest.fn(),
  validateAge: jest.fn(),
  getValidationMsg: jest.fn(),
  allowOnlyCharacter: jest.fn(),
}));

jest.mock("../../../utils/common/change.utils", () => ({
  ...jest.requireActual("../../../utils/common/change.utils"),
  authenticateType: jest.fn().mockReturnValue("myinfo"),
  handleFieldDispatch: jest.fn().mockReturnValue("mocked-flow-type"),
}));

jest.mock("../../../utils/store/last-accessed-slice", () => ({
  lastAction: {
    getField: jest.fn(),
  },
}));

const mockStore = configureStore([thunk]);

describe("Date Component", () => {
  let store: any;
  let mockProps: any;

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageId: "bd-1",
            stageInfo: {
              applicants: {
                sample_field_a_1: "1995-10-15",
              },
              products: [
                {
                  product_type: "type1",
                  product_category: "category1",
                },
              ],
            },
          },
        ],
        userInput: {
          applicants: {
            application_sourcing_a_1: null,
          },
        },
      },
      fielderror: {
        error: [],
      },
    });

    mockProps = {
      data: {
        logical_field_name: "sample_field",
        rwb_label_name: "Date of Birth",
        mandatory: "Yes",
        editable: false,
      },
      handleCallback: jest.fn(),
      handleFieldDispatch: jest.fn(),
    };
  });

  const renderComponent = () =>
    render(
      <Provider store={store}>
        <Date {...mockProps} />
      </Provider>
    );

  it("should render the component with initial values", () => {
    renderComponent();
    expect(screen.getByPlaceholderText("DD")).toHaveValue("15");
    expect(screen.getByPlaceholderText("MM")).toHaveValue("10");
    expect(screen.getByPlaceholderText("YYYY")).toHaveValue("1995");
  });

  it("should call handleCallback when a field changes", () => {
    renderComponent();
    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "16" } });

    expect(mockProps.handleCallback).toHaveBeenCalledWith(
      mockProps.data,
      "1995-10-16"
    );
  });

  it("should validate the date when all fields are filled", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(true);
    (validateService.validateAge as jest.Mock).mockReturnValue(false);

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "2000" } });

    expect(validateService.isValidDate).toHaveBeenCalledWith("2000-10-15");
    expect(validateService.validateAge).toHaveBeenCalled();
  });

  it("should dispatch age validation as invalid when age not valid", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(true);
    (validateService.validateAge as jest.Mock).mockReturnValue(true);
    (validateService.getValidationMsg as jest.Mock).mockReturnValue("is not allowed");

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "2015" } });

    const actions = store.getActions();
    expect(actions).toContainEqual(ageValidationActions.ageValidationAction.setAgeValidity(false));
  });

  it("should show an error if the date is invalid", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(false);

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "abcd" } });

    expect(screen.getByText(`${errorMsg.patterns} Date of Birth`)).toBeInTheDocument();
  });

  it("should handle mandatory fields correctly", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "" } });

    expect(screen.getByText(`Date of Birth`)).toBeInTheDocument();
  });

  it("should pad single-digit input with 0", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "7" } });
    fireEvent.blur(dayInput, { target: { value: "7" } });

    expect(dayInput).toHaveValue("07");
  });

  it("should not disable inputs if field is editable", () => {
    mockProps.data.editable = true;
    renderComponent();

    expect(screen.getByPlaceholderText("DD")).not.toBeDisabled();
  });

  it("should disable inputs if stageId is bd-1 and authenticateType is 'myinfo'", () => {
    renderComponent();
    expect(screen.getByPlaceholderText("DD")).toBeDisabled();
    expect(screen.getByPlaceholderText("MM")).toBeDisabled();
    expect(screen.getByPlaceholderText("YYYY")).toBeDisabled();
  });

  it("should dispatch lastAction.getField on focus", () => {
    renderComponent();
    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.focus(dayInput);
    expect(lastAction.getField).toHaveBeenCalledWith("sample_field");
  });

  it("should set error based on fieldErrorSelector", () => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageId: "bd-1",
            stageInfo: {
              applicants: {},
              products: [],
            },
          },
        ],
        userInput: {
          applicants: {
            application_sourcing_a_1: "1",
          },
        },
      },
      fielderror: {
        error: [{ fieldName: "sample_field" }],
      },
    });

    render(
      <Provider store={store}>
        <Date {...mockProps} />
      </Provider>
    );

    expect(screen.getByText(`Date of Birth`)).toBeInTheDocument();
  });
});

This complete file includes:

Mock setup

Rendering and interaction tests

Redux dispatch validations

Error message and format validation

Accessibility via placeholder usage


Let me know if you want this test to run with RTL + userEvent instead of fireEvent or want coverage for more edge cases.

