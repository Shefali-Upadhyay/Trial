import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import Date from "./dates";
import validateService from "../../../services/validation-service";
import errorMsg from "../../../assets/_json/error.json";
import thunk from "redux-thunk";


jest.mock("../../../services/validation-service", () => ({
  isValidDate: jest.fn(),
  calculateAge: jest.fn(),
  validateAge: jest.fn(),
  getValidationMsg: jest.fn(),
  allowOnlyCharacter: jest.fn(),
}));

jest.mock("../../../utils/common/change.utils", () => ({
  ...jest.requireActual("../../../utils/common/change.utils"),
  handleFieldDispatch: jest.fn().mockReturnValue("mocked-flow-type"), // Mocked return value
}));


jest.mock("../../../utils/store/last-accessed-slice", () => ({
  lastAction: {
    getField: jest.fn(),
  },
}));

const mockStore = configureStore([thunk]);

describe("Date Component", () => {
  let store: any;
  let mockProps: any;

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageInfo: {
              applicants: {
                sample_field_a_1: "1995-10-15",
              },
              products: [
                {
                  product_type: "type1",
                  product_category: "category1",
                },
              ],
            },
          },
        ],
      },
      fielderror: {
        error: [],
      },
    });

    mockProps = {
      data: {
        logical_field_name: "sample_field",
        rwb_label_name: "Date of Birth",
        mandatory: "Yes",
        editable: false,
      },
      handleCallback: jest.fn(),
      handleFieldDispatch: jest.fn(),
    };
  });

  const renderComponent = () =>
    render(
      <Provider store={store}>
        <Date {...mockProps} />
      </Provider>
    );

  it("should render the component with initial values", () => {
    renderComponent();
    expect(screen.getByPlaceholderText("DD")).toBeInTheDocument();
    expect(screen.getByPlaceholderText("MM")).toBeInTheDocument();
    expect(screen.getByPlaceholderText("YYYY")).toBeInTheDocument();

    expect(screen.getByPlaceholderText("DD")).toHaveValue("15");
    expect(screen.getByPlaceholderText("MM")).toHaveValue("10");
    expect(screen.getByPlaceholderText("YYYY")).toHaveValue("1995");
  });

  it("should call handleCallback when a field changes", () => {
    renderComponent();
    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "16" } });

    expect(mockProps.handleCallback).toHaveBeenCalledWith(
      mockProps.data,
      "1995-10-16"
    );
  });

  it("should validate the date when all fields are filled", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(true);
    (validateService.validateAge as jest.Mock).mockReturnValue(false);

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "2000" } });

    expect(validateService.isValidDate).toHaveBeenCalledWith("2000-10-15");
    expect(validateService.validateAge).toHaveBeenCalled();
    expect(screen.queryByText(/Date of Birth/)).toBeInTheDocument();
  });

  it("should show an error if the date is invalid", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(false);

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "abcd" } });

    expect(screen.getByText(`${errorMsg.patterns} Date of Birth`)).toBeInTheDocument();
  });

  it("should handle mandatory fields correctly", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "" } });

    expect(screen.getByText(`Date of Birth`)).toBeInTheDocument();
  });

  it("should auto-bind a single digit to a two-digit format for DD/MM", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.blur(dayInput, { target: { value: "7" } });

    expect(dayInput).toHaveValue("07");

    const monthInput = screen.getByPlaceholderText("MM");
    fireEvent.blur(monthInput, { target: { value: "3" } });

    expect(monthInput).toHaveValue("03");
  });

  it("should not disable inputs if the field is editable", () => {
    mockProps = {
      ...mockProps,
      data: { ...mockProps.data, editable: true },
    };

    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    expect(dayInput).not.toBeDisabled();
  });

  it("should set error based on fieldErrorSelector", () => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageInfo: {
              applicants: {},
              products: [],
            },
          },
        ],
      },
      fielderror: {
        error: [{ fieldName: "sample_field" }],
      },
    });

    renderComponent();
    expect(screen.getByText(`Date of Birth`)).toBeInTheDocument();
  });

  it("should auto-focus on MM input after DD is filled", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "31" } });

    expect(screen.getByPlaceholderText("MM")).toHaveFocus();
  });

  it("should auto-focus on YYYY input after MM is filled", () => {
    renderComponent();

    const monthInput = screen.getByPlaceholderText("MM");
    fireEvent.change(monthInput, { target: { value: "12" } });

    expect(screen.getByPlaceholderText("YYYY")).toHaveFocus();
  });

  it("should format single digit date inputs to two digits", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "5" } });
    fireEvent.blur(dayInput);

    expect(dayInput).toHaveValue("05");

    const monthInput = screen.getByPlaceholderText("MM");
    fireEvent.change(monthInput, { target: { value: "3" } });
    fireEvent.blur(monthInput);

    expect(monthInput).toHaveValue("03");
  });

  it("should handle valid age and invoke validation service", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(true);
    (validateService.validateAge as jest.Mock).mockReturnValue(false);

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "1990" } });

    expect(validateService.isValidDate).toHaveBeenCalledWith("1990-10-15");
    expect(validateService.validateAge).toHaveBeenCalledWith(35, "type1", "category1");
  });

  it("should show an error message for invalid age", () => {
    (validateService.isValidDate as jest.Mock).mockReturnValue(true);
    (validateService.validateAge as jest.Mock).mockReturnValue(true);
    (validateService.getValidationMsg as jest.Mock).mockReturnValue("Invalid age for the product.");

    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "2005" } });

    expect(screen.getByText("Date of Birth Invalid age for the product.")).toBeInTheDocument();
  });

  it("should hide date field if stageId matches certain condition", () => {
    store = mockStore({
      stages: {
        stages: [
          {
            stageId: "bd-3", // Modify this based on actual condition
            stageInfo: {
              applicants: {},
              products: [],
            },
          },
        ],
      },
      fielderror: { error: [] },
    });

    renderComponent();

    const dateDiv = screen.queryByText("Date of Birth");
    expect(dateDiv).toHaveClass("novisiblity");
  });

  it("should display error for mandatory fields if the date is empty", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.change(dayInput, { target: { value: "" } });

    expect(screen.getByText("Date of Birth")).toBeInTheDocument();
    expect(screen.getByText(`${errorMsg.emity} Date of Birth`)).toBeInTheDocument();
  });

  it("should disable the inputs if editable is false", () => {
    mockProps = {
      ...mockProps,
      data: { ...mockProps.data, editable: false },
    };

    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    const monthInput = screen.getByPlaceholderText("MM");
    const yearInput = screen.getByPlaceholderText("YYYY");

    expect(dayInput).toBeDisabled();
    expect(monthInput).toBeDisabled();
    expect(yearInput).toBeDisabled();
  });

  it("should allow only numeric characters for date inputs", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    fireEvent.keyPress(dayInput, { key: "a", code: "KeyA" });

    expect(validateService.allowOnlyCharacter).toHaveBeenCalled();
  });

  it("should set focus on the first editable input field", () => {
    renderComponent();

    const dayInput = screen.getByPlaceholderText("DD");
    expect(dayInput).toHaveFocus();
  });

  it("should validate that year is between 1900 and 2099", () => {
    renderComponent();

    const yearInput = screen.getByPlaceholderText("YYYY");
    fireEvent.change(yearInput, { target: { value: "1888" } });

    expect(screen.getByText(`${errorMsg.patterns} Date of Birth`)).toBeInTheDocument();
  });
});
